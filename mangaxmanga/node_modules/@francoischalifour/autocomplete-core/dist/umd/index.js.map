{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/defaultProps.ts","../../src/onInput.ts","../../src/completion.ts","../../src/propGetters.ts","../../src/onKeyDown.ts","../../src/stateReducer.ts","../../src/store.ts","../../src/autocomplete.ts","../../src/setters.ts"],"sourcesContent":["import {\n  AutocompleteOptions,\n  AutocompleteSource,\n  AutocompleteState,\n  AutocompleteSuggestion,\n  GetSources,\n  PublicAutocompleteOptions,\n  PublicAutocompleteSource,\n} from './types';\n\nexport const noop = () => {};\n\nlet autocompleteId = 0;\n\nexport function generateAutocompleteId() {\n  return `autocomplete-${autocompleteId++}`;\n}\n\nexport function getItemsCount(state: AutocompleteState<any>) {\n  if (state.suggestions.length === 0) {\n    return 0;\n  }\n\n  return state.suggestions.reduce<number>(\n    (sum, suggestion) => sum + suggestion.items.length,\n    0\n  );\n}\n\nexport function isSpecialClick(event: MouseEvent): boolean {\n  const isMiddleClick = event.button === 1;\n\n  return (\n    isMiddleClick ||\n    event.altKey ||\n    event.ctrlKey ||\n    event.metaKey ||\n    event.shiftKey\n  );\n}\n\nfunction normalizeSource<TItem>(\n  source: PublicAutocompleteSource<TItem>\n): AutocompleteSource<TItem> {\n  return {\n    getInputValue({ state }) {\n      return state.query;\n    },\n    getSuggestionUrl() {\n      return undefined;\n    },\n    onSelect({ setIsOpen }) {\n      setIsOpen(false);\n    },\n    onHighlight: noop,\n    ...source,\n  };\n}\n\nexport function normalizeGetSources<TItem>(\n  getSources: PublicAutocompleteOptions<TItem>['getSources']\n): GetSources<TItem> {\n  return (options) => {\n    return Promise.resolve(getSources(options)).then((sources) =>\n      Promise.all(\n        sources.filter(Boolean).map((source) => {\n          return Promise.resolve(normalizeSource<TItem>(source));\n        })\n      )\n    );\n  };\n}\n\nexport function getNextHighlightedIndex<TItem>(\n  moveAmount: number,\n  baseIndex: number | null,\n  itemCount: number,\n  defaultHighlightedIndex: AutocompleteOptions<TItem>['defaultHighlightedIndex']\n): number | null {\n  // We allow circular keyboard navigation from the base index.\n  // The base index can either be `null` (nothing is highlighted) or `0`\n  // (the first item is highlighted).\n  // The base index is allowed to get assigned `null` only if\n  // `props.defaultHighlightedIndex` is `null`. This pattern allows to \"stop\"\n  // by the actual query before navigating to other suggestions as seen on\n  // Google or Amazon.\n  if (baseIndex === null && moveAmount < 0) {\n    return itemCount - 1;\n  }\n\n  if (defaultHighlightedIndex !== null && baseIndex === 0 && moveAmount < 0) {\n    return itemCount - 1;\n  }\n\n  const numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;\n\n  if (numericIndex <= -1 || numericIndex >= itemCount) {\n    return defaultHighlightedIndex === null ? null : 0;\n  }\n\n  return numericIndex;\n}\n\n// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getSuggestionFromHighlightedIndex<TItem>({\n  state,\n}: {\n  state: AutocompleteState<TItem>;\n}): AutocompleteSuggestion<TItem> | undefined {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  const accumulatedSuggestionsCount = state.suggestions\n    .map((suggestion) => suggestion.items.length)\n    .reduce<number[]>((acc, suggestionCount, index) => {\n      const previousValue = acc[index - 1] || 0;\n      const nextValue = previousValue + suggestionCount;\n\n      acc.push(nextValue);\n\n      return acc;\n    }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  const suggestionIndex = accumulatedSuggestionsCount.reduce((acc, current) => {\n    if (current <= state.highlightedIndex!) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  return state.suggestions[suggestionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      â†‘\n *         (absolute: 3, relative: 1)\n * @param param0\n */\nfunction getRelativeHighlightedIndex<TItem>({\n  state,\n  suggestion,\n}: {\n  state: AutocompleteState<TItem>;\n  suggestion: AutocompleteSuggestion<TItem>;\n}): number {\n  let isOffsetFound = false;\n  let counter = 0;\n  let previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    const currentSuggestion = state.suggestions[counter];\n\n    if (currentSuggestion === suggestion) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentSuggestion.items.length;\n\n    counter++;\n  }\n\n  return state.highlightedIndex! - previousItemsOffset;\n}\n\nexport function getHighlightedItem<TItem>({\n  state,\n}: {\n  state: AutocompleteState<TItem>;\n}) {\n  const suggestion = getSuggestionFromHighlightedIndex({ state });\n\n  if (!suggestion) {\n    return null;\n  }\n\n  const item =\n    suggestion.items[getRelativeHighlightedIndex({ state, suggestion })];\n  const source = suggestion.source;\n  const itemValue = source.getInputValue({ suggestion: item, state });\n  const itemUrl = source.getSuggestionUrl({ suggestion: item, state });\n\n  return {\n    item,\n    itemValue,\n    itemUrl,\n    source,\n  };\n}\n\nexport function isOrContainsNode(parent: Node, child: Node) {\n  return parent === child || (parent.contains && parent.contains(child));\n}\n","import { AutocompleteOptions, PublicAutocompleteOptions } from './types';\nimport {\n  generateAutocompleteId,\n  getItemsCount,\n  noop,\n  normalizeGetSources,\n} from './utils';\n\nexport function getDefaultProps<TItem>(\n  props: PublicAutocompleteOptions<TItem>\n): AutocompleteOptions<TItem> {\n  const environment: typeof window = (typeof window !== 'undefined'\n    ? window\n    : {}) as typeof window;\n\n  return {\n    openOnFocus: false,\n    placeholder: '',\n    autoFocus: false,\n    defaultHighlightedIndex: null,\n    showCompletion: false,\n    stallThreshold: 300,\n    environment,\n    shouldDropdownShow: ({ state }) => getItemsCount(state) > 0,\n    onStateChange: noop,\n    onSubmit: noop,\n    ...props,\n    // Since `generateAutocompleteId` triggers a side effect (it increments\n    // and internal counter), we don't want to execute it if unnecessary.\n    id: props.id ?? generateAutocompleteId(),\n    // The following props need to be deeply defaulted.\n    initialState: {\n      highlightedIndex: null,\n      query: '',\n      completion: null,\n      suggestions: [],\n      isOpen: false,\n      status: 'idle',\n      statusContext: {},\n      context: {},\n      ...props.initialState,\n    },\n    getSources: normalizeGetSources(props.getSources),\n    navigator: {\n      navigate({ suggestionUrl }) {\n        environment.location.assign(suggestionUrl);\n      },\n      navigateNewTab({ suggestionUrl }) {\n        const windowReference = environment.open(\n          suggestionUrl,\n          '_blank',\n          'noopener'\n        );\n\n        if (windowReference) {\n          windowReference.focus();\n        }\n      },\n      navigateNewWindow({ suggestionUrl }) {\n        environment.open(suggestionUrl, '_blank', 'noopener');\n      },\n      ...props.navigator,\n    },\n  };\n}\n","import {\n  AutocompleteOptions,\n  AutocompleteSetters,\n  AutocompleteState,\n  AutocompleteStore,\n} from './types';\n\nlet lastStalledId: number | null = null;\n\ninterface OnInputParams<TItem> extends AutocompleteSetters<TItem> {\n  query: string;\n  store: AutocompleteStore<TItem>;\n  props: AutocompleteOptions<TItem>;\n  /**\n   * The next partial state to apply after the function is called.\n   *\n   * This is useful when we call `onInput` in a different scenario than an\n   * actual input. For example, we use `onInput` when we click on an item,\n   * but we want to close the dropdown in that case.\n   */\n  nextState?: Partial<AutocompleteState<TItem>>;\n}\n\nexport function onInput<TItem>({\n  query,\n  store,\n  props,\n  setHighlightedIndex,\n  setQuery,\n  setSuggestions,\n  setIsOpen,\n  setStatus,\n  setContext,\n  nextState = {},\n}: OnInputParams<TItem>): Promise<void> {\n  if (props.onInput) {\n    return Promise.resolve(\n      props.onInput({\n        query,\n        state: store.getState(),\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n      })\n    );\n  }\n\n  if (lastStalledId) {\n    clearTimeout(lastStalledId);\n  }\n\n  setHighlightedIndex(props.defaultHighlightedIndex);\n  setQuery(query);\n\n  if (query.length === 0 && props.openOnFocus === false) {\n    setStatus('idle');\n    setSuggestions(\n      store.getState().suggestions.map((suggestion) => ({\n        ...suggestion,\n        items: [],\n      }))\n    );\n    setIsOpen(\n      nextState.isOpen ?? props.shouldDropdownShow({ state: store.getState() })\n    );\n\n    return Promise.resolve();\n  }\n\n  setStatus('loading');\n\n  lastStalledId = props.environment.setTimeout(() => {\n    setStatus('stalled');\n  }, props.stallThreshold);\n\n  return props\n    .getSources({\n      query,\n      state: store.getState(),\n      setHighlightedIndex,\n      setQuery,\n      setSuggestions,\n      setIsOpen,\n      setStatus,\n      setContext,\n    })\n    .then((sources) => {\n      setStatus('loading');\n\n      // @TODO: convert `Promise.all` to fetching strategy.\n      return Promise.all(\n        sources.map((source) => {\n          return Promise.resolve(\n            source.getSuggestions({\n              query,\n              state: store.getState(),\n              setHighlightedIndex,\n              setQuery,\n              setSuggestions,\n              setIsOpen,\n              setStatus,\n              setContext,\n            })\n          ).then((items) => {\n            return {\n              source,\n              items,\n            };\n          });\n        })\n      )\n        .then((suggestions) => {\n          setStatus('idle');\n          setSuggestions(suggestions as any);\n          setIsOpen(\n            nextState.isOpen ??\n              ((query.length === 0 && props.openOnFocus) ||\n                props.shouldDropdownShow({ state: store.getState() }))\n          );\n        })\n        .catch((error) => {\n          setStatus('error');\n\n          throw error;\n        })\n        .finally(() => {\n          if (lastStalledId) {\n            clearTimeout(lastStalledId);\n          }\n        });\n    });\n}\n","import { AutocompleteOptions, AutocompleteState } from './types';\nimport { getHighlightedItem } from './utils';\n\ninterface GetCompletionProps<TItem> {\n  state: AutocompleteState<TItem>;\n  props: AutocompleteOptions<TItem>;\n}\n\nexport function getCompletion<TItem>({\n  state,\n  props,\n}: GetCompletionProps<TItem>): string | null {\n  if (\n    props.showCompletion === false ||\n    state.isOpen === false ||\n    state.highlightedIndex === null ||\n    state.status === 'stalled'\n  ) {\n    return null;\n  }\n\n  const { itemValue } = getHighlightedItem({ state })!;\n\n  // The completion should appear only if the _first_ characters of the query\n  // match with the suggestion.\n  if (\n    state.query.length > 0 &&\n    itemValue.toLocaleLowerCase().indexOf(state.query.toLocaleLowerCase()) === 0\n  ) {\n    // If the query typed has a different case than the suggestion, we want\n    // to show the completion matching the case of the query. This makes both\n    // strings overlap correctly.\n    // Example:\n    //  - query: 'Gui'\n    //  - suggestion: 'guitar'\n    //  => completion: 'Guitar'\n    const completion = state.query + itemValue.slice(state.query.length);\n\n    if (completion === state.query) {\n      return null;\n    }\n\n    return completion;\n  }\n\n  return null;\n}\n","import { onInput } from './onInput';\nimport { onKeyDown } from './onKeyDown';\nimport {\n  AutocompleteOptions,\n  AutocompleteSetters,\n  AutocompleteStore,\n  GetDropdownProps,\n  GetEnvironmentProps,\n  GetFormProps,\n  GetInputProps,\n  GetItemProps,\n  GetLabelProps,\n  GetMenuProps,\n  GetRootProps,\n} from './types';\nimport { getHighlightedItem, isOrContainsNode, isSpecialClick } from './utils';\n\ninterface GetPropGettersOptions<TItem> extends AutocompleteSetters<TItem> {\n  store: AutocompleteStore<TItem>;\n  props: AutocompleteOptions<TItem>;\n}\n\nexport function getPropGetters<TItem, TEvent, TMouseEvent, TKeyboardEvent>({\n  store,\n  props,\n  setHighlightedIndex,\n  setQuery,\n  setSuggestions,\n  setIsOpen,\n  setStatus,\n  setContext,\n}: GetPropGettersOptions<TItem>) {\n  const getEnvironmentProps: GetEnvironmentProps = (getterProps) => {\n    return {\n      // On touch devices, we do not rely on the native `blur` event of the\n      // input to close the dropdown, but rather on a custom `touchstart` event\n      // outside of the autocomplete elements.\n      // This ensures a working experience on mobile because we blur the input\n      // on touch devices when the user starts scrolling (`touchmove`).\n      onTouchStart(event) {\n        if (\n          store.getState().isOpen === false ||\n          event.target === getterProps.inputElement\n        ) {\n          return;\n        }\n\n        const isTargetWithinAutocomplete = [\n          getterProps.searchBoxElement,\n          getterProps.dropdownElement,\n        ].some((contextNode) => {\n          return (\n            contextNode &&\n            (isOrContainsNode(contextNode, event.target as Node) ||\n              isOrContainsNode(\n                contextNode,\n                props.environment.document.activeElement!\n              ))\n          );\n        });\n\n        if (isTargetWithinAutocomplete === false) {\n          store.send('blur', null);\n        }\n      },\n      // When scrolling on touch devices (mobiles, tablets, etc.), we want to\n      // mimic the native platform behavior where the input is blurred to\n      // hide the virtual keyboard. This gives more vertical space to\n      // discover all the suggestions showing up in the dropdown.\n      onTouchMove(event: TouchEvent) {\n        if (\n          store.getState().isOpen === false ||\n          getterProps.inputElement !==\n            props.environment.document.activeElement ||\n          event.target === getterProps.inputElement\n        ) {\n          return;\n        }\n\n        getterProps.inputElement.blur();\n      },\n    };\n  };\n\n  const getRootProps: GetRootProps = (rest) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': store.getState().isOpen,\n      'aria-haspopup': 'listbox',\n      'aria-owns': store.getState().isOpen ? `${props.id}-menu` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getFormProps: GetFormProps<TEvent> = (providedProps) => {\n    const { inputElement, ...rest } = providedProps;\n\n    return {\n      onSubmit: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onSubmit({\n          state: store.getState(),\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n          event,\n        });\n\n        store.send('submit', null);\n\n        if (providedProps.inputElement) {\n          providedProps.inputElement.blur();\n        }\n      },\n      onReset: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        if (props.openOnFocus) {\n          onInput({\n            query: '',\n            store,\n            props,\n            setHighlightedIndex,\n            setQuery,\n            setSuggestions,\n            setIsOpen,\n            setStatus,\n            setContext,\n          });\n        }\n        store.send('reset', null);\n\n        if (providedProps.inputElement) {\n          providedProps.inputElement.focus();\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getInputProps: GetInputProps<TEvent, TMouseEvent, TKeyboardEvent> = (\n    providedProps\n  ) => {\n    function onFocus() {\n      // We want to trigger a query when `openOnFocus` is true\n      // because the dropdown should open with the current query.\n      if (props.openOnFocus || store.getState().query.length > 0) {\n        onInput({\n          query: store.getState().query,\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n        });\n      }\n\n      store.send('focus', null);\n    }\n\n    const isTouchDevice = 'ontouchstart' in props.environment;\n    const { inputElement, maxLength = 512, ...rest } = providedProps;\n\n    return {\n      'aria-autocomplete': props.showCompletion ? 'both' : 'list',\n      'aria-activedescendant':\n        store.getState().isOpen && store.getState().highlightedIndex !== null\n          ? `${props.id}-item-${store.getState().highlightedIndex}`\n          : undefined,\n      'aria-controls': store.getState().isOpen ? `${props.id}-menu` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      value: store.getState().query,\n      id: `${props.id}-input`,\n      autoComplete: 'off',\n      autoCorrect: 'off',\n      autoCapitalize: 'off',\n      spellCheck: false,\n      autoFocus: props.autoFocus,\n      placeholder: props.placeholder,\n      maxLength,\n      onChange: (event) => {\n        onInput({\n          query: (((event as unknown) as Event)\n            .currentTarget as HTMLInputElement).value.slice(0, maxLength),\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n        });\n      },\n      onKeyDown: (event) => {\n        onKeyDown({\n          event: (event as unknown) as KeyboardEvent,\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n        });\n      },\n      onFocus,\n      onBlur: () => {\n        // We do rely on the `blur` event on touch devices.\n        // See explanation in `onTouchStart`.\n        if (!isTouchDevice) {\n          store.send('blur', null);\n        }\n      },\n      onClick: () => {\n        // When the dropdown is closed and you click on the input while\n        // the input is focused, the `onFocus` event is not triggered\n        // (default browser behavior).\n        // In an autocomplete context, it makes sense to open the menu in this\n        // case.\n        // We mimic this event by catching the `onClick` event which\n        // triggers the `onFocus` for the dropdown to open.\n        if (\n          providedProps.inputElement ===\n            props.environment.document.activeElement &&\n          !store.getState().isOpen\n        ) {\n          onFocus();\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getLabelProps: GetLabelProps = (rest) => {\n    return {\n      htmlFor: `${props.id}-input`,\n      id: `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getMenuProps: GetMenuProps = (rest) => {\n    return {\n      role: 'listbox',\n      'aria-labelledby': `${props.id}-label`,\n      id: `${props.id}-menu`,\n      ...rest,\n    };\n  };\n\n  const getDropdownProps: GetDropdownProps = (rest) => {\n    return {\n      onMouseLeave() {\n        store.send('mouseleave', null);\n      },\n      ...rest,\n    };\n  };\n\n  const getItemProps: GetItemProps<any, TMouseEvent> = (providedProps) => {\n    const { item, source, ...rest } = providedProps;\n\n    return {\n      id: `${props.id}-item-${item.__autocomplete_id}`,\n      role: 'option',\n      'aria-selected':\n        store.getState().highlightedIndex === item.__autocomplete_id,\n      onMouseMove(event) {\n        if (item.__autocomplete_id === store.getState().highlightedIndex) {\n          return;\n        }\n\n        store.send('mousemove', item.__autocomplete_id);\n\n        const highlightedItem = getHighlightedItem({\n          state: store.getState(),\n        });\n\n        if (store.getState().highlightedIndex !== null && highlightedItem) {\n          const { item, itemValue, itemUrl, source } = highlightedItem;\n\n          source.onHighlight({\n            suggestion: item,\n            suggestionValue: itemValue,\n            suggestionUrl: itemUrl,\n            source,\n            state: store.getState(),\n            setHighlightedIndex,\n            setQuery,\n            setSuggestions,\n            setIsOpen,\n            setStatus,\n            setContext,\n            event,\n          });\n        }\n      },\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the item so it\n        // can remain with the current `activeElement`.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onClick(event) {\n        // If `getSuggestionUrl` is provided, it means that the suggestion\n        // is a link, not plain text that aims at updating the query.\n        // We can therefore skip the state change because it will update\n        // the `highlightedIndex`, resulting in a UI flash, especially\n        // noticeable on mobile.\n        if (\n          source.getSuggestionUrl({\n            suggestion: item,\n            state: store.getState(),\n          }) !== undefined\n        ) {\n          return;\n        }\n\n        // We ignore all modified clicks to support default browsers' behavior.\n        if (isSpecialClick((event as unknown) as MouseEvent)) {\n          return;\n        }\n\n        const inputValue = source.getInputValue({\n          suggestion: item,\n          state: store.getState(),\n        });\n\n        onInput({\n          query: inputValue,\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n          nextState: {\n            isOpen: false,\n          },\n        }).then(() => {\n          source.onSelect({\n            suggestion: item,\n            suggestionValue: inputValue,\n            suggestionUrl: source.getSuggestionUrl({\n              suggestion: item,\n              state: store.getState(),\n            }),\n            source,\n            state: store.getState(),\n            setHighlightedIndex,\n            setQuery,\n            setSuggestions,\n            setIsOpen,\n            setStatus,\n            setContext,\n            event,\n          });\n        });\n      },\n      ...rest,\n    };\n  };\n\n  return {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getDropdownProps,\n    getMenuProps,\n    getItemProps,\n  };\n}\n","import { getCompletion } from './completion';\nimport { onInput } from './onInput';\nimport {\n  AutocompleteOptions,\n  AutocompleteSetters,\n  AutocompleteStore,\n} from './types';\nimport { getHighlightedItem } from './utils';\n\ninterface OnKeyDownOptions<TItem> extends AutocompleteSetters<TItem> {\n  event: KeyboardEvent;\n  store: AutocompleteStore<TItem>;\n  props: AutocompleteOptions<TItem>;\n}\n\nexport function onKeyDown<TItem>({\n  event,\n  store,\n  props,\n  setHighlightedIndex,\n  setQuery,\n  setSuggestions,\n  setIsOpen,\n  setStatus,\n  setContext,\n}: OnKeyDownOptions<TItem>): void {\n  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n    // Default browser behavior changes the caret placement on ArrowUp and\n    // Arrow down.\n    event.preventDefault();\n\n    store.send(event.key, { shiftKey: event.shiftKey });\n\n    const nodeItem = props.environment.document.getElementById(\n      `${props.id}-item-${store.getState().highlightedIndex}`\n    );\n    nodeItem?.scrollIntoView(false);\n\n    const highlightedItem = getHighlightedItem({\n      state: store.getState(),\n    });\n\n    if (store.getState().highlightedIndex !== null && highlightedItem) {\n      const { item, itemValue, itemUrl, source } = highlightedItem;\n\n      source.onHighlight({\n        suggestion: item,\n        suggestionValue: itemValue,\n        suggestionUrl: itemUrl,\n        source,\n        state: store.getState(),\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n        event,\n      });\n    }\n  } else if (\n    (event.key === 'Tab' ||\n      // When the user hits the right arrow and is at the end of the input\n      // query, we validate the completion.\n      (event.key === 'ArrowRight' &&\n        (event.target as HTMLInputElement).selectionStart ===\n          store.getState().query.length)) &&\n    props.showCompletion &&\n    store.getState().highlightedIndex !== null\n  ) {\n    event.preventDefault();\n\n    const query = getCompletion({ state: store.getState(), props });\n\n    if (query) {\n      onInput({\n        query,\n        store,\n        props,\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n      });\n    }\n  } else if (event.key === 'Escape') {\n    // This prevents the default browser behavior on `input[type=\"search\"]`\n    // to remove the query right away because we first want to close the\n    // dropdown.\n    event.preventDefault();\n\n    store.send(event.key, null);\n  } else if (event.key === 'Enter') {\n    // No item is selected, so we let the browser handle the native `onSubmit`\n    // form event.\n    if (\n      store.getState().highlightedIndex === null ||\n      store\n        .getState()\n        .suggestions.every((suggestion) => suggestion.items.length === 0)\n    ) {\n      return;\n    }\n\n    // This prevents the `onSubmit` event to be sent because an item is\n    // highlighted.\n    event.preventDefault();\n\n    const { item, itemValue, itemUrl, source } = getHighlightedItem({\n      state: store.getState(),\n    })!;\n\n    if (event.metaKey || event.ctrlKey) {\n      if (itemUrl !== undefined) {\n        props.navigator.navigateNewTab({\n          suggestionUrl: itemUrl,\n          suggestion: item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.shiftKey) {\n      if (itemUrl !== undefined) {\n        props.navigator.navigateNewWindow({\n          suggestionUrl: itemUrl,\n          suggestion: item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.altKey) {\n      // Keep native browser behavior\n    } else {\n      onInput({\n        query: itemValue,\n        store,\n        props,\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n        nextState: {\n          isOpen: false,\n        },\n      }).then(() => {\n        source.onSelect({\n          suggestion: item,\n          suggestionValue: itemValue,\n          suggestionUrl: itemUrl,\n          source,\n          state: store.getState(),\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n          event,\n        });\n      });\n\n      if (itemUrl !== undefined) {\n        props.navigator.navigate({\n          suggestionUrl: itemUrl,\n          suggestion: item,\n          state: store.getState(),\n        });\n      }\n    }\n  }\n}\n","import { Reducer } from './types';\nimport { getItemsCount, getNextHighlightedIndex } from './utils';\n\nexport const stateReducer: Reducer = (action, state, props) => {\n  switch (action.type) {\n    case 'setHighlightedIndex': {\n      return {\n        ...state,\n        highlightedIndex: action.value,\n      };\n    }\n\n    case 'setQuery': {\n      return {\n        ...state,\n        query: action.value,\n      };\n    }\n\n    case 'setSuggestions': {\n      return {\n        ...state,\n        suggestions: action.value,\n      };\n    }\n\n    case 'setIsOpen': {\n      return {\n        ...state,\n        isOpen: action.value,\n      };\n    }\n\n    case 'setStatus': {\n      return {\n        ...state,\n        status: action.value,\n      };\n    }\n\n    case 'setContext': {\n      return {\n        ...state,\n        context: {\n          ...state.context,\n          ...action.value,\n        },\n      };\n    }\n\n    case 'ArrowDown': {\n      return {\n        ...state,\n        highlightedIndex: getNextHighlightedIndex(\n          1,\n          state.highlightedIndex,\n          getItemsCount(state),\n          props.defaultHighlightedIndex\n        ),\n      };\n    }\n\n    case 'ArrowUp': {\n      return {\n        ...state,\n        highlightedIndex: getNextHighlightedIndex(\n          -1,\n          state.highlightedIndex,\n          getItemsCount(state),\n          props.defaultHighlightedIndex\n        ),\n      };\n    }\n\n    case 'Escape': {\n      if (state.isOpen) {\n        return {\n          ...state,\n          isOpen: false,\n        };\n      }\n\n      return {\n        ...state,\n        query: '',\n        status: 'idle',\n        statusContext: {},\n        suggestions: [],\n      };\n    }\n\n    case 'submit': {\n      return {\n        ...state,\n        highlightedIndex: null,\n        isOpen: false,\n        status: 'idle',\n        statusContext: {},\n      };\n    }\n\n    case 'reset': {\n      return {\n        ...state,\n        highlightedIndex:\n          // Since we open the menu on reset when openOnFocus=true\n          // we need to restore the highlighted index to the defaultHighlightedIndex. (DocSearch use-case)\n\n          // Since we close the menu when openOnFocus=false\n          // we lose track of the highlighted index. (Query-suggestions use-case)\n          props.openOnFocus === true ? props.defaultHighlightedIndex : null,\n        isOpen: props.openOnFocus, // @TODO: Check with UX team if we want to close the menu on reset.\n        status: 'idle',\n        statusContext: {},\n        query: '',\n      };\n    }\n\n    case 'focus': {\n      return {\n        ...state,\n        highlightedIndex: props.defaultHighlightedIndex,\n        isOpen: props.openOnFocus || state.query.length > 0,\n      };\n    }\n\n    case 'blur': {\n      return {\n        ...state,\n        isOpen: false,\n        highlightedIndex: null,\n      };\n    }\n\n    case 'mousemove': {\n      return {\n        ...state,\n        highlightedIndex: action.value,\n      };\n    }\n\n    case 'mouseleave': {\n      return {\n        ...state,\n        highlightedIndex: props.defaultHighlightedIndex,\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n","import { getCompletion } from './completion';\nimport {\n  AutocompleteOptions,\n  AutocompleteState,\n  AutocompleteStore,\n  Reducer,\n} from './types';\n\nexport function createStore<TItem>(\n  reducer: Reducer,\n  props: AutocompleteOptions<TItem>\n): AutocompleteStore<TItem> {\n  return {\n    state: props.initialState,\n    getState() {\n      return this.state;\n    },\n    send(action, payload) {\n      this.state = withCompletion(\n        reducer({ type: action, value: payload }, this.state, props),\n        props\n      );\n\n      props.onStateChange({ state: this.state });\n    },\n  };\n}\n\nfunction withCompletion<TItem>(\n  state: AutocompleteState<TItem>,\n  props: AutocompleteOptions<TItem>\n) {\n  return {\n    ...state,\n    completion: getCompletion({ state, props }),\n  };\n}\n","import { getDefaultProps } from './defaultProps';\nimport { onInput } from './onInput';\nimport { getPropGetters } from './propGetters';\nimport { getAutocompleteSetters } from './setters';\nimport { stateReducer } from './stateReducer';\nimport { createStore } from './store';\nimport { AutocompleteApi, PublicAutocompleteOptions } from './types';\n\nfunction createAutocomplete<\n  TItem extends {},\n  TEvent = Event,\n  TMouseEvent = MouseEvent,\n  TKeyboardEvent = KeyboardEvent\n>(\n  options: PublicAutocompleteOptions<TItem>\n): AutocompleteApi<TItem, TEvent, TMouseEvent, TKeyboardEvent> {\n  const props = getDefaultProps(options);\n  const store = createStore(stateReducer, props);\n\n  const {\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n  } = getAutocompleteSetters({ store });\n  const {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getDropdownProps,\n    getMenuProps,\n    getItemProps,\n  } = getPropGetters<TItem, TEvent, TMouseEvent, TKeyboardEvent>({\n    store,\n    props,\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n  });\n\n  function refresh() {\n    return onInput({\n      query: store.getState().query,\n      store,\n      props,\n      setHighlightedIndex,\n      setQuery,\n      setSuggestions,\n      setIsOpen,\n      setStatus,\n      setContext,\n    });\n  }\n\n  return {\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getInputProps,\n    getLabelProps,\n    getDropdownProps,\n    getMenuProps,\n    getItemProps,\n    refresh,\n  };\n}\n\nexport { createAutocomplete };\n","import { AutocompleteApi, AutocompleteStore } from './types';\n\ninterface GetAutocompleteSettersOptions<TItem> {\n  store: AutocompleteStore<TItem>;\n}\n\nexport function getAutocompleteSetters<TItem>({\n  store,\n}: GetAutocompleteSettersOptions<TItem>) {\n  const setHighlightedIndex: AutocompleteApi<TItem>['setHighlightedIndex'] = (\n    value\n  ) => {\n    store.send('setHighlightedIndex', value);\n  };\n\n  const setQuery: AutocompleteApi<TItem>['setQuery'] = (value) => {\n    store.send('setQuery', value);\n  };\n\n  const setSuggestions: AutocompleteApi<TItem>['setSuggestions'] = (\n    rawValue\n  ) => {\n    let baseItemId = 0;\n    const value = rawValue.map((suggestion) => ({\n      ...suggestion,\n      items: suggestion.items.map((item) => ({\n        ...item,\n        __autocomplete_id: baseItemId++,\n      })),\n    }));\n\n    store.send('setSuggestions', value);\n  };\n\n  const setIsOpen: AutocompleteApi<TItem>['setIsOpen'] = (value) => {\n    store.send('setIsOpen', value);\n  };\n\n  const setStatus: AutocompleteApi<TItem>['setStatus'] = (value) => {\n    store.send('setStatus', value);\n  };\n\n  const setContext: AutocompleteApi<TItem>['setContext'] = (value) => {\n    store.send('setContext', value);\n  };\n\n  return {\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n  };\n}\n"],"names":["noop","autocompleteId","getItemsCount","state","suggestions","length","reduce","sum","suggestion","items","normalizeGetSources","getSources","options","Promise","resolve","then","sources","all","filter","Boolean","map","source","getInputValue","query","getSuggestionUrl","onSelect","setIsOpen","onHighlight","normalizeSource","getNextHighlightedIndex","moveAmount","baseIndex","itemCount","defaultHighlightedIndex","numericIndex","getHighlightedItem","suggestionIndex","acc","suggestionCount","index","nextValue","push","current","highlightedIndex","getSuggestionFromHighlightedIndex","item","isOffsetFound","counter","previousItemsOffset","currentSuggestion","getRelativeHighlightedIndex","itemValue","itemUrl","isOrContainsNode","parent","child","contains","getDefaultProps","props","environment","window","openOnFocus","placeholder","autoFocus","showCompletion","stallThreshold","shouldDropdownShow","onStateChange","onSubmit","id","initialState","completion","isOpen","status","statusContext","context","navigator","navigate","suggestionUrl","location","assign","navigateNewTab","windowReference","open","focus","navigateNewWindow","lastStalledId","onInput","store","setHighlightedIndex","setQuery","setSuggestions","setStatus","setContext","nextState","getState","clearTimeout","setTimeout","getSuggestions","catch","error","finally","getCompletion","toLocaleLowerCase","indexOf","slice","getPropGetters","getEnvironmentProps","getterProps","onTouchStart","event","target","inputElement","searchBoxElement","dropdownElement","some","contextNode","document","activeElement","send","onTouchMove","blur","getRootProps","rest","role","undefined","getFormProps","providedProps","preventDefault","onReset","getLabelProps","htmlFor","getInputProps","onFocus","isTouchDevice","maxLength","value","autoComplete","autoCorrect","autoCapitalize","spellCheck","onChange","currentTarget","onKeyDown","key","shiftKey","nodeItem","getElementById","scrollIntoView","highlightedItem","suggestionValue","selectionStart","every","metaKey","ctrlKey","altKey","onBlur","onClick","getDropdownProps","onMouseLeave","getMenuProps","getItemProps","__autocomplete_id","onMouseMove","onMouseDown","button","isSpecialClick","inputValue","stateReducer","action","type","createStore","reducer","this","payload","withCompletion","rawValue","baseItemId","getAutocompleteSetters","refresh"],"mappings":"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"}